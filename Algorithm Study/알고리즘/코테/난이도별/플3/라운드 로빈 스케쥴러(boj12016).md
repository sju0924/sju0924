'''c++
#include <string>
#include <vector>
#include<iostream>
#include<algorithm>
#include<queue>
using namespace std;
long long int result[100001];
int n;
struct Process {
	int PID;
	long long int ExecTime;

	bool operator<(Process _other) const {

		if (this->ExecTime == _other.ExecTime) {
			return this->PID > _other.PID;
		}
		else return this->ExecTime > _other.ExecTime;
		
	}
};
class RR {
private:
	priority_queue<Process> Table;
	vector<int>run;
	vector<int>remainTime;
	long long curTime=0;
	int totallen;
	int len;

public:
	
	int getIdx(int item) {
		int front = 0, rear = len - 1, mid;
		/*
		cout << "Array run: ";
		for (int i = 0; i < len; i++) {
			cout << run[i] << " ";
		}
		cout << "\n";
		*/
		
		while (front <= rear) {
			mid = (front + rear) / 2;
			if (run[mid] < item) {
				front = mid + 1;
			}
			else if (run[mid] > item) {
				rear = mid - 1;
			}
			else {
				return mid;
			}
		}
		return -1;
	}
	long long int getPID() {
		Process curP;
		bool found = false;
		long long int idx,idx_iter = 0;
		long long int clear_iter, prev_iter = 0,clear_PID;
		int temp_len=len;
		while (!Table.empty()) {
			curP = Table.top();
			clear_iter = curP.ExecTime;
			clear_PID = curP.PID;
			//cout << "c iter: " << clear_iter << " p iter:" << prev_iter << "\n";
			if (clear_iter == prev_iter) {
				idx_iter++;
			}
			else {
				idx_iter = 0;
				temp_len = len;
			}
			//cout << "getIdx(" << curP.PID << ") = " << getIdx(curP.PID) << "\n";
			idx = getIdx(curP.PID)+idx_iter;
			curTime += (clear_iter - prev_iter) * len;

			//cout << "PID: " << clear_PID << ", curTime: " << curTime << ", idx = " << idx << "\n";

			result[clear_PID] = curTime -temp_len+idx+1;
			Table.pop();
			run.erase(run.begin() + getIdx(curP.PID));
			len--;

			prev_iter = clear_iter;

		}
		return 0;
	}
	void getTimes_io() {
		int timeInput;
		cin >> n ;
		len = n;
		totallen = n;
		for (int i = 0; i < n; i++) {			
			Process pInput;
			
			cin >> timeInput;
			pInput.PID = i;
			pInput.ExecTime = timeInput;

			Table.push(pInput);
			run.push_back(i);
			remainTime.push_back(timeInput);
		}
		
		getPID();

		for (int i = 0; i < n; i++) {
			cout << result[i] << "\n";
		}
	}

};


int main() {
	RR table;
	table.getTimes_io();
}
'''

# 사용한 것들
우선순위큐
# 접근 방법
우선순위큐로 작업 시간이 짧은 것들부터 뽑아내고, 그것의 시간만큼 전체 작업을 돌린다.<br>
전체 작업 돌리고 난 후 시간에서 작업의 갯수만큼 빼주고, 작업 시간이 짧았던 것의 인덱스를 더해주면 작업이 완료된 시간이 나온다.<br>
인덱스는 현재 작업 중인 것들의 벡터(run) 에서 관리한다.
# 기타
프로그래머스의 무지의 먹방 라이브(https://programmers.co.kr/learn/courses/30/lessons/42891) 에서 쓴 코드를 재활용하였다.<br>
다른 사람들보니까 100ms 안쪽으로 끊던데, 이 방법을 사용하니 500ms 가 나왔다. 좀 비효율적인듯